import sys
input = sys.stdin.readline

N,K = map(int,input().split())

# 0~N까지의 수중에서, K진법과 -K진법이 같은 수

"""
k = 3으로 생각해보자....
0 = 0 = 0
1 = 1 = 1
2 = 2 = 2
3 = 10 = -10 = 120
4 = 11 = -11 = 121
5 = 12 = -12 = 122
6 = 20 = -20 = 110
7 = 21 = -21 = 111
8 = 22 = -22 = 112
9 = 100 = 100 
10 = 101 = 101
11 = 102 = 102
12 = 110 = -110
.... 
27 = 1000 = -1000 = 12000
28 = 1001 = -1001 = 12001
29 = 1002 = -1002 = 12002
30 = 1010 = -1010 = 12120 (81 - 54 + 9 - 6 + 0 = 30)

즉 홀수idx 수가 0이어야함(0부터 시작)
K^2 진법으로 변환했을 때, 해당 수가 K이상이면, 홀수idx가 0이 아님.
"""

# 21
# 210(3): 18 + 3 + 0
# 23(9): 18 + 3

# 200(3),20(9) 가 되면
# 200,100 이 됨 -> 2 * 3개
# 210(3),23(9)은 안됨... -> +3개
# = 9 개
def solve(N,K):
    ans = 0
    KK = K * K

    # K^2 진법으로 변환
    # nums에는 작은 자리수부터(ex : 1,3,9 ...)로 저장됨
    nums = []
    while N:
        N,r = divmod(N,KK)
        nums.append(r)
    # print(nums)

    # 가장 큰 자리수부터 계산
    for i in range(len(nums)-1,-1,-1):
        if nums[i] < K:
            # 해당 페어에서, 홀수idx가 0인 경우
            ans += nums[i]
            ans *= K 
        else:
            ans += K
            ans *= K ** i # 남은 자리수 계산
            break
    else:
        # 정상 종료(모든 홀수idx가 0)
        ans //= K # 마지막에 곱해진 K 제거
        ans += 1 # N 자체도 포함
    return ans

print(solve(N,K))