

MAX = 1_000_000_000_000_000_001

fibo = [0 for _ in range(89)]
fibo[:3] = 1,1,2

# 1 1 2 3 5 8 13 21
# 모든 피보나치는 이전 두값으로 바꿀 수 있음
# 근데 그렇게하면 연속됨
"""
    1   2   3   5   8   13  21  34
1   o
2       o
3           o
4   o       o
5               o
6   o           o
7       o       o
8                   o
9   o               o
10      o           o


N보다 크지 않은 가장 큰 피보나치수를 a라고하면
N = a + N'
마찬가지로 N'에 대하여 b를하고 반복적으로 선언한다면
N = a + b + c + d ... + N''''...


"""
for i in range(3, 89):
    fibo[i] = fibo[i-1] + fibo[i-2]

def solve():
    N = int(input())
    ans = []
    while fibo:
        if fibo[-1] <= N:
            n = fibo.pop()
            ans.append(n)
            N -= n 
        else:
            fibo.pop()
    # ----
    # 1. "제켄도르프의 정리" 에 의해 불가능한 경우는 없음
    #   1,2,3 에 대하여, 표현은 존재함
    #   어떤수 k에 대하여, k이하에 대해 분해다 존재한다면,
    #   1-2)
    #       k+1 이 피보나치면 그냥 가능함
    #   1-3)
    #       k+1 은 두 피보나치 수의 사잇값임. F(j) < k + 1 < F(j+1)
    #       ... 증명은 복잡함 ...
    #       M = k + 1 - F(j)로 정의하면, M = k + 1 - F(j) < F(j+1) - F(j)
    #       F(j+1) = F(j) + F(j-1) 이므로 M = k + 1 - F(j) < F(j-1)
    #       M를 분해했을때의 표현은 F(j-1)이 포함될 수 없음. F(j-1)이 M보다 크기 때문
    #       따라서 k + 1 = M + F(j) 이고 M은 k이하이므로 분해됨
    # ----
    # 2. 마찬가지로, 정리에 의해 한 표현은 '유일'함
    #   똑같은 합이 나오는 다른 표현은 존재할 수 없다
    #   Z(n)이 표현의 수라고 하자
    #   Z(1) = 1임. Z(2)와 Z(3)도 1임
    #   
    # ----
    # 3.
    #   1-3을 응용하여 
    #   그냥 가장 큰 피보나치부터 빼다보면 성립
    print(len(ans))
    print(*reversed(ans))



solve()